-- Fishing Tab for FishClarity
-- Smart Detector feature for stuck detection and auto-reset

return function(config)
	local FishingTab = config.FishingTab
	local Notifier = config.Notifier

	-- Get required services and controllers
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local VirtualInputManager = game:GetService("VirtualInputManager")
	local UserInputService = game:GetService("UserInputService")
	local ReplicatedStorage = game:GetService("ReplicatedStorage")

	local player = Players.LocalPlayer
	local replion = require(game.ReplicatedStorage.Packages.Replion).Client:WaitReplion("Data")
	local ItemUtility = require(ReplicatedStorage.Shared.ItemUtility)
	local TierUtility = require(ReplicatedStorage.Shared.TierUtility)

	-- Controllers
	local FishingController
	local AnimationController

	pcall(function()
		FishingController = require(ReplicatedStorage.Controllers.FishingController)
		AnimationController = require(ReplicatedStorage.Controllers.AnimationController)
	end)

	-- Remotes
	local finishRemote = ReplicatedStorage:WaitForChild("Packages"):WaitForChild("_Index")
		:WaitForChild("sleitnick_net@0.2.0"):WaitForChild("net"):WaitForChild("RE/FishingCompleted")
	local REEquipToolFromHotbar = ReplicatedStorage:WaitForChild("Packages"):WaitForChild("_Index")
		:WaitForChild("sleitnick_net@0.2.0"):WaitForChild("net"):WaitForChild("RE/EquipToolFromHotbar")
	local REFavoriteItem = ReplicatedStorage:WaitForChild("Packages"):WaitForChild("_Index")
		:WaitForChild("sleitnick_net@0.2.0"):WaitForChild("net"):WaitForChild("RE/FavoriteItem")

	-- Smart Detector variables
	local smartDetectorEnabled = false
	local originalPosition = nil
	local originalCFrame = nil  -- Store full CFrame for rotation preservation
	local lastCastPosition = nil
	local detectorTimer = 0
	local waitTime = 15 -- default 15 seconds
	local lastResetTime = 0
	local RESET_COOLDOWN = 10
	local currentStatus = "Inactive"
	local timeDisplay, bagDisplay, statusDisplay
	local initialFishCount = 0 -- Fish count when detector started
	local fishCaughtSinceStart = 0 -- Fish caught since detector started
	
	-- Connections for Smart Detector loops
	local timerConnection = nil
	local statusConnection = nil

	-- Auto Fish variables
	local autoEquipRodEnabled = false
	local autoClickMinigameEnabled = false
	local legitDelay = 1.1
	local shakeDelay = 0.1
	local manipulationDelay = 0.12
	local autoFishConnection = nil
	local equipRodConnection = nil
	local standaloneMinigameLoop = nil

	-- ============================================
	-- LEGIT AUTO FISH VARIABLES
	-- ============================================
	local legitAutoFishEnabled = false
	local legitFishingLoop = nil
	local legitMinigameActive = false
	local legitMinigameConnection = nil

	-- ============================================
	-- AUTO EQUIP ROD VARIABLES
	-- ============================================
	local autoEquipRodEnabled = false
	local autoEquipConnection = nil

	-- ============================================
	-- EVENT FISHING VARIABLES
	-- ============================================
	local eventTeleportEnabled = false
	local selectedEvents = {}
	local prioritizedEvent = "Ghost Shark Hunt"
	local eventTeleportConnection = nil

	-- ============================================
	-- FAVORITE SYSTEM VARIABLES
	-- ============================================
	local autoFavoriteEnabled = false
	local autoUnfavoriteEnabled = false
	local selectedFishNames = {}
	local selectedRarity = {}
	local selectedVariant = {}
	local favoriteConnection = nil

	-- ============================================
	-- AUTO SELL VARIABLES
	-- ============================================
	local autoSellEnabled = false
	local sellThreshold = 0
	local sellConnection = nil
	local sellNotificationCounter = 0
	local lastSellTime = 0
	local RFSellAllItems = ReplicatedStorage.Packages._Index["sleitnick_net@0.2.0"].net["RF/SellAllItems"]

	-- AUTO FAVORITE VARIABLES
	-- ============================================
	local selectedFishNames = {}
	local selectedRarity = {}
	local selectedVariant = {}
	local autoFavoriteEnabled = false
	local autoUnfavoriteEnabled = false
	local favoriteConnection = nil
	local unfavoriteConnection = nil

	-- EVENT FISHING VARIABLES
	-- ============================================
	local selectedEvents = {}
	local eventTeleportEnabled = false
	local eventCheckConnection = nil
	local originalEventPosition = nil
	local currentEventActive = nil
	local eventPlatform = nil
	local lastEventCheck = 0
	local prioritizedEvent = nil
	local playerFrozenForEvent = false
	local eventBodyPosition = nil

	-- Check if rod is equipped
	local function isRodEquipped()
		if replion then
			local success, equippedType = pcall(function()
				return replion:GetExpect("EquippedType")
			end)
			if success and equippedType == "Fishing Rods" then
				return true
			end
		end
		return false
	end

	-- Get total fish count from inventory
	local function getTotalFishCount()
		if replion then
			local success, items = pcall(function()
				return replion:GetExpect({"Inventory", "Items"})
			end)
			if success and items then
				local count = 0
				for _, item in ipairs(items) do
					local itemData = ItemUtility.GetItemDataFromItemType("Items", item.Id)
					if itemData and itemData.Data and itemData.Data.Type == "Fish" then
						count = count + (item.Count or 1)
					end
				end
				return count
			end
		end
		return 0
	end

	-- Update status displays
	local function updateDisplays()
		if timeDisplay then
			timeDisplay:SetContent(string.format("Timer: %d/%d", detectorTimer, waitTime))
		end
		if bagDisplay then
			bagDisplay:SetContent(string.format("Fish Caught: %d", fishCaughtSinceStart))
		end
		if statusDisplay then
			statusDisplay:SetContent("Status: " .. currentStatus)
		end
	end

	-- ============================================
	-- LEGIT AUTO FISH FUNCTIONS
	-- ============================================

	-- Stop legit auto fish
	local function StopLegitAutoFish()
		legitAutoFishEnabled = false
		if legitFishingLoop then
			task.cancel(legitFishingLoop)
			legitFishingLoop = nil
		end
	end

	-- Start legit auto fish
	local function StartLegitAutoFish()
		if not FishingController then
			Notifier.new({
				Title = "Error",
				Content = "FishingController not found!",
				Duration = 3,
				Icon = "rbxassetid://95448792622941"
			})
			return
		end

		if legitAutoFishEnabled then return end
		legitAutoFishEnabled = true

		-- Function to start the actual fishing loops
		local function startFishingLoops()
			if not legitAutoFishEnabled then return end

			-- Minigame monitoring
			task.spawn(function()
				local minigameStartTime = nil

				while legitAutoFishEnabled do
					pcall(function()
						if not isRodEquipped() then
							task.wait(1)
							return
						end

						local currentMinigameActive = FishingController:GetCurrentGUID() ~= nil

						if currentMinigameActive then
							if not minigameStartTime then
								minigameStartTime = tick()
							end

							local elapsed = tick() - minigameStartTime

							if legitDelay > 0 and elapsed >= legitDelay then  -- Only fire remote if legitDelay > 0
								pcall(function() finishRemote:FireServer() end)
								minigameStartTime = nil
								-- Stop all animations and let game handle idle naturally during wait
								if AnimationController then
									pcall(function()
										AnimationController:DestroyActiveAnimationTracks()
									end)
								end
								-- Add 1.30 second wait after finishing minigame before starting next fishing cycle
								task.wait(1.30)
							else
								if elapsed >= manipulationDelay then
									pcall(function() FishingController:FishingMinigameClick() end)
								end
								task.wait(0.1)
							end
						else
							minigameStartTime = nil
							task.wait(0.02)
						end
					end)
				end
			end)

			-- Main casting loop
			legitFishingLoop = task.spawn(function()
				while legitAutoFishEnabled do
					pcall(function()
						if not isRodEquipped() then
							task.wait(1)
							return
						end

						if not FishingController:GetCurrentGUID() then
							local camera = workspace.CurrentCamera
							local screenCenter = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)

							FishingController:RequestChargeFishingRod(screenCenter, false)
							task.wait(0.1)

							local initialPower = FishingController:_getPower()
							task.wait(0.1)
							local checkPower = FishingController:_getPower()

							-- Less strict check for power charging - allow small increases
							if checkPower <= initialPower + 0.01 then
								task.wait(0.5)
								return
							end

							local attempts = 0
							repeat
								task.wait(0.02)
								local currentPower = FishingController:_getPower()
								attempts += 1
							until currentPower >= 0.92 or attempts >= 80 or not legitAutoFishEnabled

							if legitAutoFishEnabled and FishingController:_getPower() >= 0.5 then
								pcall(function()
									local power = FishingController:_getPower()

									-- Sync throw animation with cast timing to prevent desync
									if AnimationController then
										pcall(function()
											AnimationController:DestroyActiveAnimationTracks()
											AnimationController:PlayAnimation("RodThrow")
										end)
									end

									-- Execute cast immediately after animation starts
									FishingController:UpdateChargeState(nil)
									local success, fishData = FishingController:SendFishingRequestToServer(screenCenter, power)
									if success and fishData then
										task.wait(0.3)
										FishingController:FishingRodStarted(fishData)
									end
								end)
							end
							-- Dynamic cooldown detection with ping compensation
							local ping = game:GetService("Stats"):GetStat("Data Ping")
							local pingCompensation = math.min(ping / 1000 * 2, 0.1) -- Max 100ms compensation
							local cooldownEndTime = workspace:GetServerTimeNow() + 0.14 + pingCompensation -- 0.14s cooldown + ping buffer
							while workspace:GetServerTimeNow() < cooldownEndTime and legitAutoFishEnabled do
								task.wait(0.01)
							end
						else
							task.wait(0.1)
						end
					end)
				end
			end)
		end

		-- Check if rod is already equipped
		if isRodEquipped() then
			startFishingLoops()
		else
			-- Wait for rod to be equipped
			local rodEquipListener
			rodEquipListener = replion:OnChange({"EquippedType"}, function(newType)
				if newType == "Fishing Rods" and legitAutoFishEnabled then
					-- Rod equipped, start fishing
					if rodEquipListener then
						rodEquipListener:Disconnect()
					end
					startFishingLoops()
					Notifier.new({
						Title = "Legit Auto Fish",
						Content = "Rod equipped, starting auto fish",
						Duration = 3,
						Icon = "rbxassetid://95448792622941"
					})
				end
			end)
		end
	end

	-- ============================================
	-- AUTO EQUIP ROD FUNCTIONS
	-- ============================================

	-- Start auto equip rod
	local function startAutoEquipRod()
		if autoEquipConnection then
			autoEquipConnection:Disconnect()
		end

		autoEquipConnection = replion:OnChange({"EquippedType"}, function(newType)
			if autoEquipRodEnabled and newType ~= "Fishing Rods" then
				pcall(function() REEquipToolFromHotbar:FireServer(1) end)
			end
		end)
	end

	-- Stop auto equip rod
	local function stopAutoEquipRod()
		if autoEquipConnection then
			autoEquipConnection:Disconnect()
			autoEquipConnection = nil
		end
	end

	-- ============================================
	-- STANDALONE AUTO CLICK MINIGAME FUNCTIONS
	-- ============================================

	-- Start standalone auto click minigame
	local function StartStandaloneAutoClickMinigame()
		if standaloneMinigameLoop then return end

		standaloneMinigameLoop = task.spawn(function()
			local minigameStartTime = nil
			local lastMinigameState = false

			while autoClickMinigameEnabled do
				pcall(function()
					if not FishingController then
						task.wait(0.1)
						return
					end

					local currentMinigameActive = FishingController:GetCurrentGUID() ~= nil

					if currentMinigameActive then
						if not minigameStartTime then
							minigameStartTime = tick()
						end

						local minigameElapsedTime = tick() - minigameStartTime

						if legitDelay and legitDelay > 0 and minigameElapsedTime >= legitDelay then
							pcall(function()
								finishRemote:FireServer()
							end)

							minigameStartTime = nil
							task.wait(0.1)
						else
							if minigameElapsedTime >= shakeDelay then
								FishingController:FishingMinigameClick()
								task.wait(0.01)
							else
								task.wait(0.01)
							end
						end
					else
						minigameStartTime = nil
						task.wait(0.05)
					end

					lastMinigameState = currentMinigameActive
				end)
			end
			standaloneMinigameLoop = nil
		end)
	end

	-- Stop standalone auto click minigame
	local function StopStandaloneAutoClickMinigame()
		autoClickMinigameEnabled = false
		if standaloneMinigameLoop then
			pcall(function()
				task.cancel(standaloneMinigameLoop)
			end)
			standaloneMinigameLoop = nil
		end
	end

	-- ============================================
	-- RESET CHARACTER FUNCTIONS
	-- ============================================

	-- ============================================
	-- SMART DETECTOR FUNCTIONS
	-- ============================================

	-- Reset character
	local function resetCharacter()
		if not player.Character then return end

		lastResetTime = tick()
		currentStatus = "Resetting..."
		updateDisplays()

		-- Save current position RIGHT BEFORE resetting
		local savedPosition = nil
		if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
			savedPosition = player.Character.HumanoidRootPart.Position
		end

		-- Reset character
		pcall(function()
			player.Character:BreakJoints()
		end)

		-- Wait for player to respawn (detect when character is added back)
		local respawned = false
		local connection
		connection = player.CharacterAdded:Connect(function(newChar)
			respawned = true
			connection:Disconnect()
		end)

		-- Wait for respawn (max 10 seconds timeout)
		local waitStart = tick()
		while not respawned and (tick() - waitStart) < 10 do
			task.wait(0.1)
		end

		if connection then
			connection:Disconnect()
		end

		-- Wait 2 seconds after respawn finishes
		task.wait(2)

		-- Teleport back to saved position
		if savedPosition and player.Character then
			local hrp = player.Character:FindFirstChild("HumanoidRootPart")
			if hrp then
				hrp.CFrame = CFrame.new(savedPosition)
				task.wait(0.5)
			end
		end

		-- Re-equip rod
		pcall(function() REEquipToolFromHotbar:FireServer(1) end)
		task.wait(2)

		currentStatus = "Ready"
		updateDisplays()
	end

	-- Stop Smart Detector and reset all variables
	local function stopSmartDetector()
		smartDetectorEnabled = false
		
		-- Disconnect existing connections
		if timerConnection then
			timerConnection:Disconnect()
			timerConnection = nil
		end
		if statusConnection then
			statusConnection:Disconnect()
			statusConnection = nil
		end
		
		detectorTimer = 0
		originalPosition = nil
		originalCFrame = nil
		lastCastPosition = nil
		currentStatus = "Inactive"
		initialFishCount = 0
		fishCaughtSinceStart = 0
		
		-- Force update displays to reset values
		if timeDisplay then
			timeDisplay:SetContent(string.format("Timer: 0/%d", waitTime))
		end
		if bagDisplay then
			bagDisplay:SetContent("Fish Caught: 0")
		end
		if statusDisplay then
			statusDisplay:SetContent("Status: Inactive")
		end
	end

	-- Smart detector main loop
	local function startSmartDetector()
		-- Stop any existing detector first to prevent double connections
		if smartDetectorEnabled then
			stopSmartDetector()
			task.wait(0.1) -- Brief pause to ensure cleanup
		end
		
		if not FishingController then
			Notifier.new({
				Title = "Error",
				Content = "FishingController not found!",
				Duration = 3,
				Icon = "rbxassetid://95448792622941"
			})
			return
		end

		-- FULLY RESET all variables when starting
		smartDetectorEnabled = true
		detectorTimer = 0
		initialFishCount = getTotalFishCount()
		fishCaughtSinceStart = 0
		lastResetTime = 0
		originalPosition = nil
		originalCFrame = nil
		lastCastPosition = nil
		currentStatus = isRodEquipped() and "Active" or "No Rod"

		-- Save original position and rotation
		if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
			local hrp = player.Character.HumanoidRootPart
			originalPosition = hrp.Position  -- Keep as Vector3 for distance calculations
			originalCFrame = hrp.CFrame     -- Store full CFrame for rotation preservation
			lastCastPosition = originalPosition
		end

		-- Force update all displays with fresh values
		if timeDisplay then
			timeDisplay:SetContent(string.format("Timer: 0/%d", waitTime))
		end
		if bagDisplay then
			bagDisplay:SetContent("Fish Caught: 0")
		end
		if statusDisplay then
			statusDisplay:SetContent("Status: " .. currentStatus)
		end

		-- Timer countdown connection (runs every second)
		local lastTimerUpdate = tick()
		timerConnection = RunService.Heartbeat:Connect(function()
			if not smartDetectorEnabled then return end
			
			local currentTime = tick()
			if currentTime - lastTimerUpdate >= 1 then
				lastTimerUpdate = currentTime
				
				-- Only increment timer if rod is equipped
				if isRodEquipped() then
					detectorTimer = detectorTimer + 1
					updateDisplays()

					if detectorTimer >= waitTime then
						if (tick() - lastResetTime) >= RESET_COOLDOWN then
							Notifier.new({
								Title = "Smart Detector",
								Content = "Timer expired - resetting character",
								Duration = 3,
								Icon = "rbxassetid://95448792622941"
							})
							resetCharacter()
							detectorTimer = 0
						else
							detectorTimer = 0
						end
					end
				else
					-- Reset timer if no rod equipped
					detectorTimer = 0
					updateDisplays()
				end
			end
		end)

		-- Status monitoring connection (runs every 0.1 seconds)
		local lastMinigameTime = nil
		local lastStatusUpdate = tick()
		statusConnection = RunService.Heartbeat:Connect(function()
			if not smartDetectorEnabled then return end
			
			local currentTime = tick()
			if currentTime - lastStatusUpdate < 0.1 then return end
			lastStatusUpdate = currentTime
			
			pcall(function()
				if not isRodEquipped() then
					currentStatus = "No Rod"
					updateDisplays()
					return
				end

				local currentMinigameActive = FishingController:GetCurrentGUID() ~= nil

				if currentMinigameActive then
					currentStatus = "Minigame"
					updateDisplays()

					if not lastMinigameTime then
						lastMinigameTime = tick()
					end

					local elapsed = tick() - lastMinigameTime

					if elapsed >= 1.1 then
						-- Complete the minigame
						pcall(function() finishRemote:FireServer() end)
						lastMinigameTime = nil

						-- Check if fish was caught and handle stuck recovery
						task.spawn(function()
							task.wait(0.5)
							local currentTime = tick()
							
							-- Check if minigame is still active (stuck)
							if FishingController:GetCurrentGUID() ~= nil and smartDetectorEnabled and (currentTime - lastResetTime) >= RESET_COOLDOWN then
								print("Minigame stuck detected! Resetting character...")
								lastResetTime = currentTime
								local wasEnabled = smartDetectorEnabled
								smartDetectorEnabled = false

								pcall(function()
									if player.Character then player.Character:BreakJoints() end
								end)

								print("Character reset initiated")
								task.wait(5)

								if wasEnabled then
									if originalCFrame and player.Character then
										local hrp = player.Character:FindFirstChild("HumanoidRootPart")
										if hrp then
											print("Teleporting to original position with rotation:", originalCFrame.Position, originalCFrame.LookVector)
											hrp.CFrame = originalCFrame
											task.wait(0.5)
										end
									end

									print("Re-equipping rod...")
									pcall(function() REEquipToolFromHotbar:FireServer(1) end)
									task.wait(2)

									if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
										local hrp = player.Character.HumanoidRootPart
										originalPosition = hrp.Position
										originalCFrame = hrp.CFrame
										lastCastPosition = originalPosition
										print("Position and rotation updated after reset")
									end

									print("Stuck recovery completed - restarting smart detector")
									task.wait(1)
									startSmartDetector()
								end
							else
								-- Check if fish was caught normally
								local newFishCount = getTotalFishCount()
								if newFishCount > initialFishCount then
									-- Fish was caught, reset timer
									detectorTimer = 0
									fishCaughtSinceStart = newFishCount - initialFishCount
									currentStatus = "Fish Caught"
									updateDisplays()

									task.wait(1)
									currentStatus = "Active"
									updateDisplays()
								end
							end
						end)
					end
				else
					if lastMinigameTime then
						lastMinigameTime = nil
					end

					-- Simple status detection: if rod equipped and not in minigame, check if casting
					if FishingController._getPower then
						local currentPower = FishingController:_getPower()

						-- If power is above 0, player is actively casting
						if currentPower > 0 then
							currentStatus = "Casting"
						else
							-- Rod equipped, not in minigame, power is 0 = Idle
							currentStatus = "Idle"
						end
					else
						-- Fallback: if we can't check power, assume Idle when rod is equipped
						currentStatus = "Idle"
					end

					updateDisplays()
				end
			end)
		end)
	end

	local function getFishInventory()
		local inventory = {}
		if replion then
			local success, items = pcall(function()
				return replion:GetExpect({"Inventory", "Items"})
			end)
			if success and items then
				for _, item in ipairs(items) do
					local itemData = ItemUtility.GetItemDataFromItemType("Items", item.Id)
					if itemData and itemData.Data and itemData.Data.Type == "Fish" then
						table.insert(inventory, item)
					end
				end
			end
		end
		return inventory
	end

	-- ============================================
	-- SELL FUNCTIONS
	-- ============================================

	local function sellAllItems()
		pcall(function()
			RFSellAllItems:InvokeServer()
		end)
	end

	local function autoSellFish()
		if not autoSellEnabled or sellThreshold <= 0 then return end
		
		local currentTime = tick()
		if currentTime - lastSellTime >= sellThreshold then
			sellAllItems()
			lastSellTime = currentTime
			
			sellNotificationCounter = sellNotificationCounter + 1
			
			if sellNotificationCounter >= 5 then
				Notifier.new({
					Title = "Auto Sell",
					Content = "Sold all items",
					Duration = 2,
					Icon = "rbxassetid://95448792622941"
				})
				sellNotificationCounter = 0
			end
		end
	end

	local function startAutoSell()
		if sellConnection then
			sellConnection:Disconnect()
		end
		
		lastSellTime = tick()
		
		sellConnection = RunService.Heartbeat:Connect(function()
			if autoSellEnabled then
				autoSellFish()
			end
		end)
	end

	local function stopAutoSell()
		if sellConnection then
			sellConnection:Disconnect()
			sellConnection = nil
		end
		sellNotificationCounter = 0
		lastSellTime = 0
	end

	-- ============================================
	-- FAVORITE FUNCTIONS
	-- ============================================

	local function favoriteFish(uuid)
		pcall(function()
			REFavoriteItem:FireServer(uuid)
		end)
	end

	local function unfavoriteAllFish()
		local items = getFishInventory()
		local unfavoriteCount = 0
		
		for _, item in ipairs(items) do
			if item.Favorited then
				favoriteFish(item.UUID)
				unfavoriteCount = unfavoriteCount + 1
				task.wait(0.05)
			end
		end
		
		Notifier.new({
			Title = "Unfavorite All",
			Content = "Unfavorited " .. unfavoriteCount .. " fish",
			Duration = 3,
			Icon = "rbxassetid://95448792622941"
		})
	end

	local function autoUnfavoriteFish()
		if not autoUnfavoriteEnabled then return end
		
		local items = getFishInventory()
		for _, item in ipairs(items) do
			if item.Favorited then
				local itemData = ItemUtility.GetItemDataFromItemType("Items", item.Id)
				if itemData then
					local fishName = itemData.Data.Name
					local shouldUnfavorite = false
					
					if next(selectedFishNames) ~= nil then
						for selectedName, isSelected in pairs(selectedFishNames) do
							if isSelected and fishName == selectedName then
								if next(selectedVariant) then
									for variantName, variantSelected in pairs(selectedVariant) do
										if variantSelected and item.Metadata and item.Metadata.VariantId == variantName then
											shouldUnfavorite = true
											break
										end
									end
								end
								if next(selectedRarity) then
									local fishTier = itemData.Data.Tier
									if fishTier then
										local tierInfo = TierUtility:GetTier(fishTier)
										if tierInfo then
											for rarityName, raritySelected in pairs(selectedRarity) do
												if raritySelected and tierInfo.Name == rarityName then
													shouldUnfavorite = true
													break
												end
											end
										end
									end
								end
								if not next(selectedVariant) and not next(selectedRarity) then
									shouldUnfavorite = true
								end
							end
						end
					end
					
					if next(selectedVariant) or next(selectedRarity) then
						if next(selectedVariant) then
							for variantName, variantSelected in pairs(selectedVariant) do
								if variantSelected and item.Metadata and item.Metadata.VariantId == variantName then
									shouldUnfavorite = true
									break
								end
							end
						end
						if next(selectedRarity) then
							local fishTier = itemData.Data.Tier
							if fishTier then
								local tierInfo = TierUtility:GetTier(fishTier)
								if tierInfo then
									for rarityName, raritySelected in pairs(selectedRarity) do
										if raritySelected and tierInfo.Name == rarityName then
											shouldUnfavorite = true
											break
										end
									end
								end
							end
						end
					end
					
					if shouldUnfavorite then
						favoriteFish(item.UUID)
						task.wait(0.05)
					end
				end
			end
		end
	end

	local function autoFavoriteFish()
		if not autoFavoriteEnabled then return end
		
		local items = getFishInventory()
		
		for _, item in ipairs(items) do
			if not item.Favorited then
				local itemData = ItemUtility.GetItemDataFromItemType("Items", item.Id)
				if itemData then
					local fishName = itemData.Data.Name
					local shouldFavorite = false
					
					if next(selectedFishNames) ~= nil then
						for selectedName, isSelected in pairs(selectedFishNames) do
							if isSelected and fishName == selectedName then
								shouldFavorite = true
								
								if next(selectedVariant) then
									local variantMatch = false
									for variantName, variantSelected in pairs(selectedVariant) do
										if variantSelected and item.Metadata and item.Metadata.VariantId == variantName then
											variantMatch = true
											break
										end
									end
									if not variantMatch then
										shouldFavorite = false
									end
								end
								
								if next(selectedRarity) then
									local rarityMatch = false
									local fishTier = itemData.Data.Tier
									if fishTier then
										local tierInfo = TierUtility:GetTier(fishTier)
										if tierInfo then
											for rarityName, raritySelected in pairs(selectedRarity) do
												if raritySelected and tierInfo.Name == rarityName then
													rarityMatch = true
													break
												end
											end
										end
									end
									if not rarityMatch then
										shouldFavorite = false
									end
								end
								
								break
							end
						end
					else
						if next(selectedVariant) or next(selectedRarity) then
							shouldFavorite = true
							
							if next(selectedVariant) then
								local variantMatch = false
								for variantName, variantSelected in pairs(selectedVariant) do
									if variantSelected and item.Metadata and item.Metadata.VariantId == variantName then
										variantMatch = true
										break
									end
								end
								if not variantMatch then
									shouldFavorite = false
								end
							end
							
							if next(selectedRarity) then
								local rarityMatch = false
								local fishTier = itemData.Data.Tier
								if fishTier then
									local tierInfo = TierUtility:GetTier(fishTier)
									if tierInfo then
										for rarityName, raritySelected in pairs(selectedRarity) do
											if raritySelected and tierInfo.Name == rarityName then
												rarityMatch = true
												break
											end
										end
									end
								end
								if not rarityMatch then
									shouldFavorite = false
								end
							end
						end
					end
					
					if shouldFavorite then
						favoriteFish(item.UUID)
						task.wait(0.05)
					end
				end
			end
		end
	end

	local function startAutoFavorite()
		if favoriteConnection then
			favoriteConnection:Disconnect()
		end
		
		favoriteConnection = RunService.Heartbeat:Connect(function()
			if autoFavoriteEnabled then
				autoFavoriteFish()
				task.wait(1)
			end
		end)
	end

	local function stopAutoFavorite()
		if favoriteConnection then
			favoriteConnection:Disconnect()
			favoriteConnection = nil
		end
	end

	local function startAutoUnfavorite()
		if unfavoriteConnection then
			unfavoriteConnection:Disconnect()
		end
		
		unfavoriteConnection = RunService.Heartbeat:Connect(function()
			if autoUnfavoriteEnabled then
				autoUnfavoriteFish()
				task.wait(1)
			end
		end)
	end

	local function stopAutoUnfavorite()
		if unfavoriteConnection then
			unfavoriteConnection:Disconnect()
			unfavoriteConnection = nil
		end
	end

	-- ============================================
	-- UI CREATION
	-- ============================================

	-- Create Fishing Features section
	local FishingFeaturesSection = FishingTab:DrawSection({
		Name = "Fishing Features",
	});

	-- Status displays
	timeDisplay = FishingFeaturesSection:AddParagraph({
		Title = "Time",
		Content = "Timer: 0/" .. waitTime
	});

	bagDisplay = FishingFeaturesSection:AddParagraph({
		Title = "Bag",
		Content = "Fish Caught: " .. fishCaughtSinceStart
	});

	statusDisplay = FishingFeaturesSection:AddParagraph({
		Title = "Status",
		Content = "Status: " .. currentStatus
	});

	-- Smart Detector toggle
	FishingFeaturesSection:AddToggle({
		Name = "Smart Detector",
		Default = false,
		Callback = function(enabled)
			if enabled then
				startSmartDetector()
			else
				stopSmartDetector()
			end
		end,
	});

	-- Wait Time slider
	FishingFeaturesSection:AddSlider({
		Name = "Wait Time",
		Min = 10,
		Max = 25,
		Default = 15,
		Round = 0,
		Callback = function(value)
			waitTime = value
			-- Don't update timer here, just change the selected time
			updateDisplays()
		end,
	});

	-- ============================================
	-- AUTO FISH SECTION
	-- ============================================

	local AutoFishSection = FishingTab:DrawSection({
		Name = "Auto Fish",
		Icon = "rbxassetid://95448792622941"
	});

	-- Legit Auto Fish toggle
	AutoFishSection:AddToggle({
		Name = "Legit Auto Fish",
		Default = false,
		Callback = function(Value)
			if Value then
				StartLegitAutoFish()
				Notifier.new({
					Title = "Legit Auto Fish",
					Content = "Legit auto fish enabled",
					Duration = 3,
					Icon = "rbxassetid://95448792622941"
				});
			else
				StopLegitAutoFish()
				Notifier.new({
					Title = "Legit Auto Fish",
					Content = "Legit auto fish disabled",
					Duration = 2,
					Icon = "rbxassetid://95448792622941"
				});
			end
		end,
	});

	-- Auto Equip Rod toggle
	AutoFishSection:AddToggle({
		Name = "Auto Equip Rod",
		Default = false,
		Callback = function(Value)
			autoEquipRodEnabled = Value

			if Value then
				startAutoEquipRod()
				Notifier.new({
					Title = "Auto Equip Rod",
					Content = "Auto Equip Rod enabled",
					Duration = 3,
					Icon = "rbxassetid://95448792622941"
				});
			else
				stopAutoEquipRod()
				Notifier.new({
					Title = "Auto Equip Rod",
					Content = "Auto Equip Rod disabled",
					Duration = 2,
					Icon = "rbxassetid://95448792622941"
				});
			end
		end,
	});

	-- Auto Click Minigame toggle
	AutoFishSection:AddToggle({
		Name = "Auto Click Minigame",
		Default = false,
		Callback = function(Value)
			autoClickMinigameEnabled = Value

			if Value then
				StartStandaloneAutoClickMinigame()
				Notifier.new({
					Title = "Auto Click Minigame",
					Content = "Auto Click Minigame enabled",
					Duration = 3,
					Icon = "rbxassetid://95448792622941"
				});
			else
				StopStandaloneAutoClickMinigame()
				Notifier.new({
					Title = "Auto Click Minigame",
					Content = "Auto Click Minigame disabled",
					Duration = 2,
					Icon = "rbxassetid://95448792622941"
				});
			end
		end,
	});

	-- Legit Delay textbox
	AutoFishSection:AddTextBox({
		Name = "Legit Delay",
		Default = "1.1",
		Placeholder = "0-10 seconds",
		Callback = function(Text)
			local value = tonumber(Text)
			if value and value >= 0 and value <= 10 then
				legitDelay = value
			end
		end,
	});

	-- MiniGame Delay textbox
	AutoFishSection:AddTextBox({
		Name = "MiniGame Delay",
		Default = "0.1",
		Placeholder = "0+ seconds",
		Callback = function(Text)
			local value = tonumber(Text)
			if value and value >= 0 then
				shakeDelay = value
			end
		end,
	});

	-- Manipulation Delay textbox
	AutoFishSection:AddTextBox({
		Name = "Manipulation Delay",
		Default = "0.12",
		Placeholder = "0.1-1 seconds",
		Callback = function(Text)
			local value = tonumber(Text)
			if value and value >= 0.1 and value <= 1 then
				manipulationDelay = value
			end
		end,
	});

	-- ============================================
	-- SELL SECTION
	-- ============================================

	local SellSection = FishingTab:DrawSection({
		Name = "Sell",
	});

	SellSection:AddToggle({
		Name = "Auto Sell",
		Default = false,
		Callback = function(Value)
			autoSellEnabled = Value
			
			if Value then
				startAutoSell()
				Notifier.new({
					Title = "Auto Sell Enabled",
					Content = "Will auto-sell every " .. sellThreshold .. " seconds",
					Duration = 3,
					Icon = "rbxassetid://95448792622941"
				});
			else
				stopAutoSell()
				Notifier.new({
					Title = "Auto Sell Disabled",
					Content = "Auto sell turned off",
					Duration = 2,
					Icon = "rbxassetid://95448792622941"
				});
			end
		end,
	});

	SellSection:AddTextBox({
		Name = "Sell Timer (seconds)",
		Default = "0",
		Placeholder = "0+ seconds",
		Callback = function(Text)
			local value = tonumber(Text)
			if value and value >= 0 then
				sellThreshold = value
			end
		end,
	});

	SellSection:AddButton({
		Name = "Sell All",
		Callback = function()
			sellAllItems()
			Notifier.new({
				Title = "Sell All",
				Content = "Sold all items",
				Duration = 2,
				Icon = "rbxassetid://95448792622941"
			});
		end,
	});

	-- ============================================
	-- EVENT FISHING SECTION
	-- ============================================

	-- Event Functions
	local function findEventPart(eventName)
		local workspace = game:GetService("Workspace")
		local menuRings = workspace:FindFirstChild("!!! MENU RINGS")
		if not menuRings then
			return nil
		end
		
		for _, props in ipairs(menuRings:GetChildren()) do
			if props.Name == "Props" then
				local eventFolder = props:FindFirstChild(eventName)
				if eventFolder then
					local part = eventFolder:FindFirstChild("Part") or eventFolder:FindFirstChild(eventName)
					if part and part:IsA("BasePart") then
						return part
					end
				end
			end
		end
		
		return nil
	end

	local function freezePlayerForEvent()
		if not playerFrozenForEvent then return end -- Don't freeze if we're supposed to be unfrozen
		
		if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
			local hrp = player.Character.HumanoidRootPart
			
			if eventBodyPosition then
				eventBodyPosition:Destroy()
			end
			
			eventBodyPosition = Instance.new("BodyPosition")
			eventBodyPosition.Position = hrp.Position
			eventBodyPosition.MaxForce = Vector3.new(10000, 10000, 10000) -- Increased from 4000 to 10000
			eventBodyPosition.D = 2000 -- Increased from 1000 to 2000
			eventBodyPosition.P = 25000 -- Increased from 10000 to 25000
			eventBodyPosition.Parent = hrp
			
			playerFrozenForEvent = true
		end
	end

	local function unfreezePlayerForEvent()
		-- Destroy the main event body position
		if eventBodyPosition then
			pcall(function()
				eventBodyPosition:Destroy()
			end)
			eventBodyPosition = nil
		end
		
		-- Destroy any BodyPosition on the player's HumanoidRootPart
		if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
			local hrp = player.Character.HumanoidRootPart
			for _, constraint in ipairs(hrp:GetChildren()) do
				if constraint:IsA("BodyPosition") then
					pcall(function()
						constraint:Destroy()
					end)
				end
			end
		end
		
		playerFrozenForEvent = false
	end

	local function teleportToEvent(eventPart, eventName)
		if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
			local hrp = player.Character.HumanoidRootPart
			local targetPosition = eventPart.Position + Vector3.new(0, 7, 0)
			
			if not originalEventPosition then
				originalEventPosition = hrp.Position
			end
			
			if eventPlatform then
				eventPlatform:Destroy()
			end
			
			eventPlatform = Instance.new("Part")
			eventPlatform.Size = Vector3.new(10, 1, 10)
			eventPlatform.Transparency = 1
			eventPlatform.Anchored = true
			eventPlatform.CanCollide = true
			eventPlatform.Position = targetPosition
			eventPlatform.Parent = workspace
			
			task.wait(0.1)
			hrp.CFrame = CFrame.new(targetPosition + Vector3.new(0, 3, 0))
			
			task.wait(0.3)
			pcall(function()
				REEquipToolFromHotbar:FireServer(1)
			end)
			
			task.wait(0.5)
			
			currentEventActive = eventName
			playerFrozenForEvent = true
			freezePlayerForEvent()
			StartLegitAutoFish()
			
			return true
		end
		return false
	end

	local function returnPlayerToOriginal()
		if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
			local hrp = player.Character.HumanoidRootPart
			
			if eventPlatform then
				eventPlatform:Destroy()
				eventPlatform = nil
			end
			
			if originalEventPosition then
				hrp.CFrame = CFrame.new(originalEventPosition)
				originalEventPosition = nil
			end
			
			task.wait(0.5)
			
			currentEventActive = nil
			StopLegitAutoFish()
			unfreezePlayerForEvent()
			
			Notifier.new({
				Title = "Event Teleport",
				Content = "Returned to original position",
				Duration = 2,
				Icon = "rbxassetid://95448792622941"
			})
		end
	end

	local function checkForActiveEvents()
		if not eventTeleportEnabled then return end
		
		local workspace = game:GetService("Workspace")
		local menuRings = workspace:FindFirstChild("!!! MENU RINGS")
		if not menuRings then return end
		
		local activeEvents = {}
		for eventName, _ in pairs(selectedEvents) do
			local eventPart = findEventPart(eventName)
			if eventPart then
				table.insert(activeEvents, {name = eventName, part = eventPart})
			end
		end
		
		if prioritizedEvent and not selectedEvents[prioritizedEvent] then
			local eventPart = findEventPart(prioritizedEvent)
			if eventPart then
				table.insert(activeEvents, {name = prioritizedEvent, part = eventPart})
			end
		end
		
		if currentEventActive then
			local stillActive = false
			for _, event in ipairs(activeEvents) do
				if event.name == currentEventActive then
					stillActive = true
					break
				end
			end
			
			if not stillActive then
				StopLegitAutoFish()
				unfreezePlayerForEvent()
				
				currentEventActive = nil
				
				Notifier.new({
					Title = "Event Ended",
					Content = "Event completed, checking for more...",
					Duration = 2,
					Icon = "rbxassetid://95448792622941"
				})
				
				local prioritizedActive = false
				local prioritizedEventData = nil
				if prioritizedEvent and selectedEvents[prioritizedEvent] then
					for _, event in ipairs(activeEvents) do
						if event.name == prioritizedEvent then
							prioritizedActive = true
							prioritizedEventData = event
							break
						end
					end
				end
				
				if prioritizedActive then
					teleportToEvent(prioritizedEventData.part, prioritizedEventData.name)
					Notifier.new({
						Title = "Event Teleport",
						Content = "Teleported to prioritized " .. prioritizedEventData.name,
						Duration = 3,
						Icon = "rbxassetid://95448792622941"
					})
				elseif #activeEvents > 0 then
					local randomEvent = activeEvents[math.random(1, #activeEvents)]
					teleportToEvent(randomEvent.part, randomEvent.name)
					
					Notifier.new({
						Title = "Event Teleport",
						Content = "Teleported to " .. randomEvent.name,
						Duration = 3,
						Icon = "rbxassetid://95448792622941"
					})
				else
					returnPlayerToOriginal()
				end
			end
		else
			if #activeEvents > 0 then
				local prioritizedActive = false
				local prioritizedEventData = nil
				if prioritizedEvent and selectedEvents[prioritizedEvent] then
					for _, event in ipairs(activeEvents) do
						if event.name == prioritizedEvent then
							prioritizedActive = true
							prioritizedEventData = event
							break
						end
					end
				end
				
				if prioritizedActive then
					teleportToEvent(prioritizedEventData.part, prioritizedEventData.name)
					Notifier.new({
						Title = "Event Teleport",
						Content = "Teleported to prioritized " .. prioritizedEventData.name,
						Duration = 3,
						Icon = "rbxassetid://95448792622941"
					})
				else
					local randomEvent = activeEvents[math.random(1, #activeEvents)]
					teleportToEvent(randomEvent.part, randomEvent.name)
					
					Notifier.new({
						Title = "Event Teleport",
						Content = "Teleported to " .. randomEvent.name,
						Duration = 3,
						Icon = "rbxassetid://95448792622941"
					})
				end
			end
		end
	end

	local function startEventTeleport()
		if eventCheckConnection then
			eventCheckConnection:Disconnect()
		end
		
		eventCheckConnection = RunService.Heartbeat:Connect(function()
			if eventTeleportEnabled then
				local currentTime = tick()
				if currentTime - lastEventCheck >= 2 then
					checkForActiveEvents()
					lastEventCheck = currentTime
				end
			end
		end)
	end

	local function stopEventTeleport()
		if eventCheckConnection then
			eventCheckConnection:Disconnect()
			eventCheckConnection = nil
		end
		
		lastEventCheck = 0
		
		if eventPlatform then
			eventPlatform:Destroy()
			eventPlatform = nil
		end
		
		returnPlayerToOriginal()
	end

	local EventSection = FishingTab:DrawSection({
		Name = "Event Fishing"
	});

	local EventDropdown = EventSection:AddDropdown({
		Name = "Select Events",
		Default = {},
		Multi = true,
		Values = {"Ghost Shark Hunt", "Megalodon Hunt", "Shark Hunt"},
		Callback = function(Value)
			selectedEvents = Value
		end,
	});

	EventSection:AddButton({
		Name = "Clear Events",
		Callback = function()
			selectedEvents = {}
			if EventDropdown and EventDropdown.SetValue then
				EventDropdown:SetValue({})
			end
			Notifier.new({
				Title = "Cleared",
				Content = "Event selection cleared",
				Duration = 2,
				Icon = "rbxassetid://95448792622941"
			});
		end,
	});

	local PrioritizeDropdown = EventSection:AddDropdown({
		Name = "Prioritize Event",
		Default = "Ghost Shark Hunt",
		Values = {"Ghost Shark Hunt", "Megalodon Hunt", "Shark Hunt"},
		Callback = function(Value)
			prioritizedEvent = Value
		end,
	});

	EventSection:AddButton({
		Name = "Clear Priority",
		Callback = function()
			prioritizedEvent = nil
			if PrioritizeDropdown and PrioritizeDropdown.SetValue then
				PrioritizeDropdown:SetValue(nil)
			end
			Notifier.new({
				Title = "Cleared",
				Content = "Priority event cleared",
				Duration = 2,
				Icon = "rbxassetid://95448792622941"
			});
		end,
	});

	EventSection:AddToggle({
		Name = "Auto Event Teleport",
		Default = false,
		Callback = function(Value)
			eventTeleportEnabled = Value
			
			if Value then
				if not selectedEvents or (type(selectedEvents) == "table" and next(selectedEvents) == nil) then
					Notifier.new({
						Title = "No Events Selected",
						Content = "Please select at least one event",
						Duration = 3,
						Icon = "rbxassetid://95448792622941"
					});
					eventTeleportEnabled = false
					return
				end
				
				startEventTeleport()
				Notifier.new({
					Title = "Auto Event Enabled",
					Content = "Will teleport to selected events",
					Duration = 3,
					Icon = "rbxassetid://95448792622941"
				});
			else
				stopEventTeleport()
				Notifier.new({
					Title = "Auto Event Disabled",
					Content = "Event teleportation stopped",
					Duration = 2,
					Icon = "rbxassetid://95448792622941"
				});
			end
		end,
	});

	-- ============================================
	-- FAVORITE SECTION
	-- ============================================

	local FavoriteSection = FishingTab:DrawSection({
		Name = "Favorite",
	});

	-- Function to create a searchable dropdown
	local function createSearchableDropdown(section, name, allValues, callback)
		local selectedValues = {}
		local dropdown -- Forward declare

		-- Create a text box for search input
		local searchBox = section:AddTextBox({
			Name = name .. " Search",
			Default = "",
			Placeholder = "Type to search...",
			Callback = function(searchText)
				-- Filter values based on search
				local filteredValues = {}
				if searchText and searchText ~= "" then
					searchText = string.lower(searchText)
					for _, value in ipairs(allValues) do
						if string.lower(value):find(searchText, 1, true) then
							table.insert(filteredValues, value)
						end
					end
				else
					-- Show all values when search is empty
					filteredValues = allValues
				end

				-- Update dropdown with filtered values
				if dropdown and dropdown.SetValues then
					dropdown:SetValues(filteredValues)
				end
			end,
		});

		-- Create a regular dropdown that we'll populate based on search
		dropdown = section:AddDropdown({
			Name = name,
			Default = {},
			Multi = true,
			Values = allValues, -- Start with all values
			Callback = function(Value)
				selectedValues = Value
				if callback then
					callback(Value)
				end
			end,
		});

		-- Return the dropdown object for external access
		return {
			Dropdown = dropdown,
			SearchBox = searchBox,
			GetSelectedValues = function() return selectedValues end,
			SetSelectedValues = function(values)
				selectedValues = values
				if dropdown and dropdown.SetValue then
					dropdown:SetValue(values)
				end
			end,
			ClearSelection = function()
				selectedValues = {}
				if dropdown and dropdown.SetValue then
					dropdown:SetValue({})
				end
			end,
			RefreshValues = function(newValues)
				allValues = newValues or allValues
				if dropdown and dropdown.SetValues then
					dropdown:SetValues(allValues)
				end
			end
		}
	end

	local FishNamesDropdown = createSearchableDropdown(FavoriteSection, "Favorite By Name", {
		"Abyshorn Fish", "Abyss Seahorse", "Ancient Arapaima", "Ancient Relic Crocodile", "Ancient Whale",
		"Angler Fish", "Armor Catfish", "Arowana", "Ash Basslet", "Astra Damsel", "Axolotl", "Azure Damsel",
		"Baby Pumpkin Shark", "Ballina Angelfish", "Banded Butterfly", "Bandit Angelfish", "Barracuda Fish",
		"Beanie Leedsicheye", "Blackcap Basslet", "Bleekers Damsel", "Blob Fish", "Blob Shark", "Blue Lobster",
		"Blue-Banded Goby", "Blueflame Ray", "Blumato Clownfish", "Boa Angelfish", "Boar Fish", "Bone Whale",
		"Bumblebee Grouper", "Candy Butterfly", "Candy Corn Eel", "Candycane Lobster", "Catfish", "Charmed Tang",
		"Christmas Trophy 2024", "Christmastree Longnose", "Chrome Tuna", "Clownfish", "Coal Tang", "Coney Fish",
		"Conspi Angelfish", "Copperband Butterfly", "Corazon Damsel", "Cow Clownfish", "Crocodile", "Crystal Crab",
		"Crystal Salamander", "Dark Eel", "Dark Pumpkin Appafish", "Dark Tentacle", "Darwin Clownfish", "Dead Fish",
		"Dead Scary Clownfish", "Dead Spooky Koi Fish", "Dead Zombie Shark", "Deep Sea Crab", "Domino Damsel",
		"Dorhey Tang", "Dotted Stingray", "Drippy Tucanare", "Eerie Shark", "Electric Eel", "Elshark Gran Maja",
		"Enchanted Angelfish", "Fade Tang", "Fangtooth", "Festive Goby", "Festive Pufferfish", "Fire Goby",
		"Firecoal Damsel", "Flame Angelfish", "Flat Fish", "Flying Fish", "Frankenstein Longsnapper",
		"Freshwater Piranha", "Frog", "Frostborn Shark", "Gar Fish", "Ghastly Crab", "Ghastly Hermit Crab",
		"Ghost Shark", "Ghost Spiralfish", "Ghost Worm Fish", "Giant Squid", "Gingerbread Clownfish",
		"Gingerbread Shark", "Gingerbread Tang", "Gingerbread Turtle", "Goliath Tiger", "Great Christmas Whale",
		"Great Whale", "Greenbee Grouper", "Hammerhead Mummy", "Hammerhead Shark", "Hawks Turtle", "Hermit Crab",
		"Herring Fish", "Hybodus Shark", "Jellyfish", "Jennifer Dottyback", "Jewel Tang", "Kau Cardinal",
		"King Crab", "King Jelly", "King Mackerel", "Korean Angelfish", "Lake Sturgeon", "Lava Butterfly",
		"Lavafin Tuna", "Lined Cardinal Fish", "Lion Fish", "Lobster", "Lochness Monster", "Loggerhead Turtle",
		"Longnose Butterfly", "Loving Shark", "Luminous Fish", "Magic Tang", "Magma Goby", "Magma Shark",
		"Mammoth Appafish", "Manoai Statue Fish", "Manta Ray", "Maroon Butterfly", "Masked Angelfish",
		"Maze Angelfish", "Megalodon", "Mistletoe Damsel", "Monk Fish", "Monster Shark", "Moorish Idol",
		"Mosasaur Shark", "Mossy Fishlet", "Mossy Vampire Fish", "Narwhal", "Orange Basslet", "Orangy Goby",
		"Orca", "Panther Eel", "Panther Grouper", "Parrot Fish", "Patriot Tang", "Pilot Fish", "Pink Dolphin",
		"Pink Smith Damsel", "Plasma Shark", "Prismy Seahorse", "Pufferfish", "Pumpkin Angler Fish",
		"Pumpkin Butterfly Fish", "Pumpkin Carved Shark", "Pumpkin Hermit Crab", "Pumpkin Jellyfish",
		"Pumpkin Ray", "Pumpkin StoneTurtle", "Pygmy Goby", "Queen Crab", "Racoon Butterfly Fish", "Red Goatfish",
		"Red Snapper", "Reef Chromis", "Robot Kraken", "Rockfish", "Rockform Cardianl", "Runic Wispeye",
		"Sacred Guardian Squid", "Sail Fish", "Sail Tang", "Salmon", "Saw Fish", "Scare", "Scary Clownfish",
		"Scissortail Dartfish", "Sharp One", "Sheepshead Fish", "Shrimp Goby", "Silver Tuna",
		"Skeleton Angler Fish", "Skeleton Fish", "Skeleton Narwhal", "Skunk Tilefish", "Slurpfish Chromis",
		"Spear Guardian", "Specked Butterfly", "Spooky Koi Fish", "Spooky Peafish", "Spotted Lantern Fish",
		"Starfish", "Starjam Tang", "Strawberry Dotty", "Strippled Seahorse", "Sushi Cardinal", "Swordfish",
		"Synodontis", "Talon Serpent", "Temple Spokes Tuna", "Thin Armor Shark", "Thresher Shark",
		"Toxic Jellyfish", "Tricolore Butterfly", "Unicorn Tang", "Vampire Squid", "Vintage Blue Tang",
		"Vintage Damsel", "Viperangler Fish", "Viperfish", "Volcanic Basslet", "Volsail Tang", "Wahoo",
		"Watanabei Angelfish", "Water Snake", "Waveback Fish", "White Clownfish", "White Tang", "Wild Serpent",
		"Witch Fish", "Witch Koi Fish", "Wizard Stingray", "Worm Fish", "Wraithfin Abyssal", "Yello Damselfish",
		"Yellowfin Tuna", "Yellowstate Angelfish", "Zebra Snakehead", "Zombie Megalodon", "Zombie Shark",
		"Zoster Butterfly"
	}, function(Value)
		selectedFishNames = Value
	end);

	FavoriteSection:AddButton({
		Name = "Clear Fish Names",
		Callback = function()
			selectedFishNames = {}
			if FishNamesDropdown and FishNamesDropdown.ClearSelection then
				FishNamesDropdown.ClearSelection()
			end
			Notifier.new({
				Title = "Cleared",
				Content = "Fish names selection cleared",
				Duration = 2,
				Icon = "rbxassetid://95448792622941"
			});
		end,
	});

	local RarityDropdown = FavoriteSection:AddDropdown({
		Name = "Favorite By Rarity",
		Default = {},
		Multi = true,
		Values = {"Common", "Uncommon", "Rare", "Epic", "Legendary", "Mythical"},
		Callback = function(Value)
			selectedRarity = Value
		end,
	});

	FavoriteSection:AddButton({
		Name = "Clear Rarity",
		Callback = function()
			selectedRarity = {}
			if RarityDropdown and RarityDropdown.SetValue then
				RarityDropdown:SetValue({})
			end
			Notifier.new({
				Title = "Cleared",
				Content = "Rarity selection cleared",
				Duration = 2,
				Icon = "rbxassetid://95448792622941"
			});
		end,
	});

	local VariantDropdown = FavoriteSection:AddDropdown({
		Name = "Favorite By Variant",
		Default = {},
		Multi = true,
		Values = {
			"Albino", "Corrupt", "Fairy Dust", "Festive", "Frozen", "Galaxy",
			"Gemstone", "Ghost", "Gold", "Holographic", "Lightning",
			"Midnight", "Radioactive", "Stone"
		},
		Callback = function(Value)
			selectedVariant = Value
		end,
	});

	FavoriteSection:AddButton({
		Name = "Clear Variant",
		Callback = function()
			selectedVariant = {}
			if VariantDropdown and VariantDropdown.SetValue then
				VariantDropdown:SetValue({})
			end
			Notifier.new({
				Title = "Cleared",
				Content = "Variant selection cleared",
				Duration = 2,
				Icon = "rbxassetid://95448792622941"
			});
		end,
	});

	FavoriteSection:AddToggle({
		Name = "Auto Favorite",
		Default = false,
		Callback = function(Value)
			autoFavoriteEnabled = Value
			
			if Value then
				startAutoFavorite()
				Notifier.new({
					Title = "Auto Favorite Enabled",
					Content = "Will auto-favorite matching fish",
					Duration = 3,
					Icon = "rbxassetid://95448792622941"
				});
			else
				stopAutoFavorite()
				Notifier.new({
					Title = "Auto Favorite Disabled",
					Content = "Auto favorite turned off",
					Duration = 2,
					Icon = "rbxassetid://95448792622941"
				});
			end
		end,
	});

	FavoriteSection:AddToggle({
		Name = "Auto Unfavorite",
		Default = false,
		Callback = function(Value)
			autoUnfavoriteEnabled = Value
			
			if Value then
				startAutoUnfavorite()
				Notifier.new({
					Title = "Auto Unfavorite Enabled",
					Content = "Will auto-unfavorite matching fish",
					Duration = 3,
					Icon = "rbxassetid://95448792622941"
				});
			else
				stopAutoUnfavorite()
				Notifier.new({
					Title = "Auto Unfavorite Disabled",
					Content = "Auto unfavorite turned off",
					Duration = 2,
					Icon = "rbxassetid://95448792622941"
				});
			end
		end,
	});

	FavoriteSection:AddButton({
		Name = "Unfavorite All",
		Callback = function()
			unfavoriteAllFish()
		end,
	});

	-- Favorite Functions
	local function getFishInventory()
		local inventory = {}
		if replion then
			local success, items = pcall(function()
				return replion:GetExpect({"Inventory", "Items"})
			end)
			if success and items then
				for _, item in ipairs(items) do
					local itemData = ItemUtility.GetItemDataFromItemType("Items", item.Id)
					if itemData and itemData.Data and itemData.Data.Type == "Fish" then
						table.insert(inventory, item)
					end
				end
			end
		end
		return inventory
	end

	local function favoriteFish(uuid)
		pcall(function()
			REFavoriteItem:FireServer(uuid)
		end)
	end

	local function unfavoriteAllFish()
		local items = getFishInventory()
		local unfavoriteCount = 0
		
		for _, item in ipairs(items) do
			if item.Favorited then
				favoriteFish(item.UUID)
				unfavoriteCount = unfavoriteCount + 1
				task.wait(0.05)
			end
		end
		
		Notifier.new({
			Title = "Unfavorite All",
			Content = "Unfavorited " .. unfavoriteCount .. " fish",
			Duration = 3,
			Icon = "rbxassetid://95448792622941"
		})
	end

	local function autoUnfavoriteFish()
		if not autoUnfavoriteEnabled then return end
		
		local items = getFishInventory()
		
		for _, item in ipairs(items) do
			if item.Favorited then
				local itemData = ItemUtility.GetItemDataFromItemType("Items", item.Id)
				if itemData then
					local fishName = itemData.Data.Name
					local shouldUnfavorite = false
					
					if next(selectedFishNames) ~= nil then
						for selectedName, isSelected in pairs(selectedFishNames) do
							if isSelected and fishName == selectedName then
								shouldUnfavorite = true
								
								if next(selectedVariant) then
									local variantMatch = false
									for variantName, variantSelected in pairs(selectedVariant) do
										if variantSelected and item.Metadata and item.Metadata.VariantId == variantName then
											variantMatch = true
											break
										end
									end
									if not variantMatch then
										shouldUnfavorite = false
									end
								end
								
								if next(selectedRarity) then
									local rarityMatch = false
									local fishTier = itemData.Data.Tier
									if fishTier then
										local tierInfo = TierUtility:GetTier(fishTier)
										if tierInfo then
											for rarityName, raritySelected in pairs(selectedRarity) do
												if raritySelected and tierInfo.Name == rarityName then
													rarityMatch = true
													break
												end
											end
										end
									end
									if not rarityMatch then
										shouldUnfavorite = false
									end
								end
								
								break
							end
						end
					else
						if next(selectedVariant) or next(selectedRarity) then
							shouldUnfavorite = true
							
							if next(selectedVariant) then
								local variantMatch = false
								for variantName, variantSelected in pairs(selectedVariant) do
									if variantSelected and item.Metadata and item.Metadata.VariantId == variantName then
										variantMatch = true
										break
									end
								end
								if not variantMatch then
									shouldUnfavorite = false
								end
							end
							
							if next(selectedRarity) then
								local rarityMatch = false
								local fishTier = itemData.Data.Tier
								if fishTier then
									local tierInfo = TierUtility:GetTier(fishTier)
									if tierInfo then
										for rarityName, raritySelected in pairs(selectedRarity) do
											if raritySelected and tierInfo.Name == rarityName then
												rarityMatch = true
												break
											end
										end
									end
								end
								if not rarityMatch then
									shouldUnfavorite = false
								end
							end
						end
					end
					
					if shouldUnfavorite then
						favoriteFish(item.UUID)
						task.wait(0.05)
					end
				end
			end
		end
	end

	local function autoFavoriteFish()
		if not autoFavoriteEnabled then return end
		
		local items = getFishInventory()
		
		for _, item in ipairs(items) do
			if not item.Favorited then
				local itemData = ItemUtility.GetItemDataFromItemType("Items", item.Id)
				if itemData then
					local fishName = itemData.Data.Name
					local shouldFavorite = false
					
					if next(selectedFishNames) ~= nil then
						for selectedName, isSelected in pairs(selectedFishNames) do
							if isSelected and fishName == selectedName then
								shouldFavorite = true
								
								if next(selectedVariant) then
									local variantMatch = false
									for variantName, variantSelected in pairs(selectedVariant) do
										if variantSelected and item.Metadata and item.Metadata.VariantId == variantName then
											variantMatch = true
											break
										end
									end
									if not variantMatch then
										shouldFavorite = false
									end
								end
								
								if next(selectedRarity) then
									local rarityMatch = false
									local fishTier = itemData.Data.Tier
									if fishTier then
										local tierInfo = TierUtility:GetTier(fishTier)
										if tierInfo then
											for rarityName, raritySelected in pairs(selectedRarity) do
												if raritySelected and tierInfo.Name == rarityName then
													rarityMatch = true
													break
												end
											end
										end
									end
									if not rarityMatch then
										shouldFavorite = false
									end
								end
								
								break
							end
						end
					else
						if next(selectedVariant) or next(selectedRarity) then
							shouldFavorite = true
							
							if next(selectedVariant) then
								local variantMatch = false
								for variantName, variantSelected in pairs(selectedVariant) do
									if variantSelected and item.Metadata and item.Metadata.VariantId == variantName then
										variantMatch = true
										break
									end
								end
								if not variantMatch then
									shouldFavorite = false
								end
							end
							
							if next(selectedRarity) then
								local rarityMatch = false
								local fishTier = itemData.Data.Tier
								if fishTier then
									local tierInfo = TierUtility:GetTier(fishTier)
									if tierInfo then
										for rarityName, raritySelected in pairs(selectedRarity) do
											if raritySelected and tierInfo.Name == rarityName then
												rarityMatch = true
												break
											end
										end
									end
								end
								if not rarityMatch then
									shouldFavorite = false
								end
							end
						end
					end
					
					if shouldFavorite then
						favoriteFish(item.UUID)
						task.wait(0.05)
					end
				end
			end
		end
	end

	local function startAutoFavorite()
		if favoriteConnection then
			favoriteConnection:Disconnect()
		end
		
		favoriteConnection = RunService.Heartbeat:Connect(function()
			if autoFavoriteEnabled then
				autoFavoriteFish()
				task.wait(1)
			end
		end)
	end

	local function stopAutoFavorite()
		if favoriteConnection then
			favoriteConnection:Disconnect()
			favoriteConnection = nil
		end
	end

	local function startAutoUnfavorite()
		if unfavoriteConnection then
			unfavoriteConnection:Disconnect()
		end
		
		unfavoriteConnection = RunService.Heartbeat:Connect(function()
			if autoUnfavoriteEnabled then
				autoUnfavoriteFish()
				task.wait(1)
			end
		end)
	end

	local function stopAutoUnfavorite()
		if unfavoriteConnection then
			unfavoriteConnection:Disconnect()
			unfavoriteConnection = nil
		end
	end
end
